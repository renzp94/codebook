<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="/favicon.ico" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="theme-color" content="#333333" />
		<link rel="stylesheet" href="/assets/styles/global.css" />
		<title>第四章：语法和语义</title>

		

		<link rel="modulepreload" href="/./_app/start-97f7b82c.js">
		<link rel="modulepreload" href="/./_app/chunks/vendor-d00531f1.js">
		<link rel="modulepreload" href="/./_app/pages/__layout.svelte-b0488dc3.js">
		<link rel="modulepreload" href="/./_app/pages/article/__layout.svelte-9a26e2ca.js">
		<link rel="modulepreload" href="/./_app/pages/article/[category]/[id].svelte-35c0c78b.js">
		<link rel="modulepreload" href="/./_app/chunks/utils-a81d5505.js">
		<link rel="stylesheet" href="/./_app/assets/start-a8cd1609.css">
		<link rel="stylesheet" href="/./_app/assets/pages/__layout.svelte-dfbf40bb.css">
		<link rel="stylesheet" href="/./_app/assets/pages/article/__layout.svelte-1448dd73.css">
		<link rel="stylesheet" href="/./_app/assets/pages/article/[category]/[id].svelte-7f79f039.css">

		<script type="module">
			import { start } from "/./_app/start-97f7b82c.js";
			start({
				target: document.querySelector("#svelte"),
				paths: {"base":"","assets":"/."},
				session: {},
				host: location.host,
				route: true,
				spa: false,
				trailing_slash: "never",
				hydrate: {
					status: 200,
					error: null,
					nodes: [
						import("/./_app/pages/__layout.svelte-b0488dc3.js"),
						import("/./_app/pages/article/__layout.svelte-9a26e2ca.js"),
						import("/./_app/pages/article/[category]/[id].svelte-35c0c78b.js")
					],
					page: {
						host: location.host, // TODO this is redundant
						path: "/article/lisp/20210325215311",
						query: new URLSearchParams(""),
						params: {"category":"lisp","id":"20210325215311"}
					}
				}
			});
		</script>
	</head>
	<body>
		<div id="svelte">



<section class="svelte-jbk32v"><header class="svelte-jbk32v"><a href="/"><img class="logo svelte-jbk32v" src="/assets/images/logo.png" alt="code book logo"></a>
<a class="github svelte-jbk32v" href="https://github.com/renzp94" target="_blank"><i class="iconfont icon-github svelte-jbk32v"></i></a></header>
	<main><section><main class="svelte-1fbldbu">

<section class="md"><h1 class="title">第四章：语法和语义</h1>
  <div class="info svelte-1vg5uky"><div class="author svelte-1vg5uky">作者：renzp94</div>
    <div class="time">时间：2021-03-25 21:53:25</div></div>

  <div class="md-content"><p>大多数编程语言，语言的处理器(无论是解释器或编译器)的操作方式都类似黑箱操作。
在黑箱内部，语言的处理器通常分成子系统。
一个典型的任务划分思路：将处理器分为三个阶段，每个阶段为下一个阶段提供内容。</p>
<ul>
<li>一个词法分析器将字符流分拆成语元并将其送进一个解析器</li>
<li>解析器再根据该语言的语法在程序中构建一个表达式的树形表示。这棵树被称为抽象语法树。</li>
<li>随即被送进一个求值器，求值器要么直接解释它，要么将其编译成魔种其他语言(如：机器码)。</li>
</ul>
<p>Common lisp 定义了两个黑箱：读取器、求值器</p>
<ul>
<li>读取器：将文本转为 lisp 对象。</li>
<li>求值器：用这些对象实现语言的语义。</li>
</ul>
<p>每个黑箱都定义了一个语法层面。读取器定义了字符串如何被转换为 S-表达式的 lisp 对象。
S-表达式适用于由任意对象及其他列表所组成的列表，因此 S-表达式可用来表达任意树形表达式。
求值器随后定义了一种构建在 S-表达式之上的 lisp 形式的语法。</p>
<p>此种黑箱划分带来的后果：</p>
<ul>
<li>可将 S-表达式用作一种可暴露的数据格式来表达源代码之外的数据。</li>
<li>由于语言的语义是用对象树而非字符串定义而成的，则可通过语言本身来生成代码，则可通过处理现有的数据生成代码，从而达到“可编程的编程语言”的效果，即 lisp 宏的本意。</li>
</ul>
<h1 id="s-表达式">S-表达式</h1>
<p>S-表达式的基本元素是列表、原子。
列表由括号所包围，并可包含任何数量的由空格所分隔的元素。
原子是所有其他内容。</p>
<ul>
<li><p>原子：数字、字符串、名字。</p>
</li>
<li><p>数字：任何数位的序列都会被读取为一个数字。可为整数、比值、小数、科学计数法</p>
</li>
<li><p>字符串：用双引号包含的都是字符串。用反斜杠进行转义。</p>
</li>
<li><p>字符：用#\表示，如：#\a 表示字符 a</p>
</li>
<li><p>名字：由称为符号的对象表示。如：format、hello-world、<em>db</em></p>
</li>
</ul>
<p>十个字符不能出现在名字中：开括号、闭括号、双引号、单引号、反引号、逗号、冒号、分好、反斜杠、竖线。
如真想用的，则需要用反斜杠转义或将含有需要转义的字符名字用竖线包起来。</p>
<p>读取器将名字转化为符号对象的方式：</p>
<ul>
<li>当读取名字时，读取器将所有名字中未转义的字符都转为大写。</li>
<li>为了确保同一个文本名字总是被读取成相同的符号，读取器保留这个符号之后，在一个称为包的表汇总查询带有相同名字的已有符号，若找不到，则创建一个新的符号并添加到表中。否则返回那个符号。</li>
</ul>
<p>名字的约定：</p>
<ul>
<li>全局变量：开始和结尾用<em>。如：</em>db*</li>
<li>常量：开始和结尾用+。如：+zero+</li>
</ul>
<p>lisp 求值方式：将求值器看做一个函数，接收一个句法良好定义的 lisp 形式作为参数并返回一个值。</p>
<p>原子可被分为两个类别：符号和所有其他内容。
符号在作为 lisp 形式被求值时会被看作一个变量名，并会被求值为该变量的当前值。
所有原子都是自求值对象。</p>
<p>lisp 中的真假值为：T 和 NIL
其中 NIL 既是原子也是列表，nil 是空列表。
另一类自求值符号是关键字符号(以冒号开始的符号)，当读取器保留这样一个名字时，会自动定义一个以此命名的常量变量并以该符号作为其值。</p>
<h1 id="函数调用">函数调用</h1>
<p>函数调用规则：除第一个以外，所有的列表元素它们自身必须是一个形态良好的 lisp 形式。
调用格式：(函数名 参数列表)</p>
<p>函数的所有参数都在函数被调用之前求值。</p>
<h1 id="特殊操作符">特殊操作符</h1>
<p>如：if
if 规则：对第一个表达式求值，为非 nil 则执行第二个表达式，否则执行第三个表达式。
quote 规则：接收一个参数，并不求值返回。即：将参数不经处理直接返回。语法糖为：&#39;(单引号)</p>
<h1 id="宏">宏</h1>
<p>宏是一个以 S-表达式为其参数的函数，并返回一个 lisp 形式然后对其求值并用改制取代宏形式。</p>
<p>宏形式的求值过程：</p>
<ul>
<li>首先宏形式的元素不经求值即被传递到宏函数里</li>
<li>其次，由宏函数所返回的形式(展开式)按照正常的求值规则进行求值。
即宏的求值一般为两个阶段：宏展开阶段、展开式求值阶段。</li>
</ul>
<h1 id="真、假、等价">真、假、等价</h1>
<p>符号 nil 是唯一的一个假值。其他所有的都是真值。
符号 T 是标准的真值。
等价</p>
<ul>
<li><p>eq：用来测试“对象标识”，只有当两个对象相同时，才等价。如：相同值的数字和字符用 eq 比较是不等价的。</p>
</li>
<li><p>eql：与 eq 相似，可保证当相同类型的两个对象标识相同的数字或字符值时，才等价。</p>
</li>
<li><p>equal：具有相同内容，就等价。</p>
</li>
<li><p>equalp：在比较字符串时忽略大小写。</p>
</li>
</ul>
<h1 id="格式化代码">格式化代码</h1>
<p>​ 保持美观的代码风格，可方便查找错误及阅读代码。</p>
</div>
</section></main>
</section></main>
	
<div class="back-top svelte-9c9s8u" style="bottom: 5rem;right: 0.625rem;display: none"><i class="iconfont icon-back-top"></i>
</div>
</section>



	<script type="svelte-data" url="20210325215311.json">{"status":200,"statusText":"","headers":{"content-type":"text/plain;charset=UTF-8"},"body":"{\"title\":\"第四章：语法和语义\",\"slug\":\"Lisp\",\"time\":\"2021-03-25T21:53:25.000Z\",\"author\":\"renzp94\",\"status\":\"done\",\"html\":\"\u003Cp\u003E大多数编程语言，语言的处理器(无论是解释器或编译器)的操作方式都类似黑箱操作。\\n在黑箱内部，语言的处理器通常分成子系统。\\n一个典型的任务划分思路：将处理器分为三个阶段，每个阶段为下一个阶段提供内容。\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E一个词法分析器将字符流分拆成语元并将其送进一个解析器\u003C\u002Fli\u003E\\n\u003Cli\u003E解析器再根据该语言的语法在程序中构建一个表达式的树形表示。这棵树被称为抽象语法树。\u003C\u002Fli\u003E\\n\u003Cli\u003E随即被送进一个求值器，求值器要么直接解释它，要么将其编译成魔种其他语言(如：机器码)。\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003ECommon lisp 定义了两个黑箱：读取器、求值器\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E读取器：将文本转为 lisp 对象。\u003C\u002Fli\u003E\\n\u003Cli\u003E求值器：用这些对象实现语言的语义。\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003E每个黑箱都定义了一个语法层面。读取器定义了字符串如何被转换为 S-表达式的 lisp 对象。\\nS-表达式适用于由任意对象及其他列表所组成的列表，因此 S-表达式可用来表达任意树形表达式。\\n求值器随后定义了一种构建在 S-表达式之上的 lisp 形式的语法。\u003C\u002Fp\u003E\\n\u003Cp\u003E此种黑箱划分带来的后果：\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E可将 S-表达式用作一种可暴露的数据格式来表达源代码之外的数据。\u003C\u002Fli\u003E\\n\u003Cli\u003E由于语言的语义是用对象树而非字符串定义而成的，则可通过语言本身来生成代码，则可通过处理现有的数据生成代码，从而达到“可编程的编程语言”的效果，即 lisp 宏的本意。\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch1 id=\\\"s-表达式\\\"\u003ES-表达式\u003C\u002Fh1\u003E\\n\u003Cp\u003ES-表达式的基本元素是列表、原子。\\n列表由括号所包围，并可包含任何数量的由空格所分隔的元素。\\n原子是所有其他内容。\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Cp\u003E原子：数字、字符串、名字。\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E数字：任何数位的序列都会被读取为一个数字。可为整数、比值、小数、科学计数法\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E字符串：用双引号包含的都是字符串。用反斜杠进行转义。\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E字符：用#\\\\表示，如：#\\\\a 表示字符 a\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003E名字：由称为符号的对象表示。如：format、hello-world、\u003Cem\u003Edb\u003C\u002Fem\u003E\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003E十个字符不能出现在名字中：开括号、闭括号、双引号、单引号、反引号、逗号、冒号、分好、反斜杠、竖线。\\n如真想用的，则需要用反斜杠转义或将含有需要转义的字符名字用竖线包起来。\u003C\u002Fp\u003E\\n\u003Cp\u003E读取器将名字转化为符号对象的方式：\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E当读取名字时，读取器将所有名字中未转义的字符都转为大写。\u003C\u002Fli\u003E\\n\u003Cli\u003E为了确保同一个文本名字总是被读取成相同的符号，读取器保留这个符号之后，在一个称为包的表汇总查询带有相同名字的已有符号，若找不到，则创建一个新的符号并添加到表中。否则返回那个符号。\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003E名字的约定：\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E全局变量：开始和结尾用\u003Cem\u003E。如：\u003C\u002Fem\u003Edb*\u003C\u002Fli\u003E\\n\u003Cli\u003E常量：开始和结尾用+。如：+zero+\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Cp\u003Elisp 求值方式：将求值器看做一个函数，接收一个句法良好定义的 lisp 形式作为参数并返回一个值。\u003C\u002Fp\u003E\\n\u003Cp\u003E原子可被分为两个类别：符号和所有其他内容。\\n符号在作为 lisp 形式被求值时会被看作一个变量名，并会被求值为该变量的当前值。\\n所有原子都是自求值对象。\u003C\u002Fp\u003E\\n\u003Cp\u003Elisp 中的真假值为：T 和 NIL\\n其中 NIL 既是原子也是列表，nil 是空列表。\\n另一类自求值符号是关键字符号(以冒号开始的符号)，当读取器保留这样一个名字时，会自动定义一个以此命名的常量变量并以该符号作为其值。\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"函数调用\\\"\u003E函数调用\u003C\u002Fh1\u003E\\n\u003Cp\u003E函数调用规则：除第一个以外，所有的列表元素它们自身必须是一个形态良好的 lisp 形式。\\n调用格式：(函数名 参数列表)\u003C\u002Fp\u003E\\n\u003Cp\u003E函数的所有参数都在函数被调用之前求值。\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"特殊操作符\\\"\u003E特殊操作符\u003C\u002Fh1\u003E\\n\u003Cp\u003E如：if\\nif 规则：对第一个表达式求值，为非 nil 则执行第二个表达式，否则执行第三个表达式。\\nquote 规则：接收一个参数，并不求值返回。即：将参数不经处理直接返回。语法糖为：&#39;(单引号)\u003C\u002Fp\u003E\\n\u003Ch1 id=\\\"宏\\\"\u003E宏\u003C\u002Fh1\u003E\\n\u003Cp\u003E宏是一个以 S-表达式为其参数的函数，并返回一个 lisp 形式然后对其求值并用改制取代宏形式。\u003C\u002Fp\u003E\\n\u003Cp\u003E宏形式的求值过程：\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E首先宏形式的元素不经求值即被传递到宏函数里\u003C\u002Fli\u003E\\n\u003Cli\u003E其次，由宏函数所返回的形式(展开式)按照正常的求值规则进行求值。\\n即宏的求值一般为两个阶段：宏展开阶段、展开式求值阶段。\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch1 id=\\\"真、假、等价\\\"\u003E真、假、等价\u003C\u002Fh1\u003E\\n\u003Cp\u003E符号 nil 是唯一的一个假值。其他所有的都是真值。\\n符号 T 是标准的真值。\\n等价\u003C\u002Fp\u003E\\n\u003Cul\u003E\\n\u003Cli\u003E\u003Cp\u003Eeq：用来测试“对象标识”，只有当两个对象相同时，才等价。如：相同值的数字和字符用 eq 比较是不等价的。\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003Eeql：与 eq 相似，可保证当相同类型的两个对象标识相同的数字或字符值时，才等价。\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003Eequal：具有相同内容，就等价。\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003Cli\u003E\u003Cp\u003Eequalp：在比较字符串时忽略大小写。\u003C\u002Fp\u003E\\n\u003C\u002Fli\u003E\\n\u003C\u002Ful\u003E\\n\u003Ch1 id=\\\"格式化代码\\\"\u003E格式化代码\u003C\u002Fh1\u003E\\n\u003Cp\u003E​ 保持美观的代码风格，可方便查找错误及阅读代码。\u003C\u002Fp\u003E\\n\"}"}</script>
</div>
	</body>
</html>
